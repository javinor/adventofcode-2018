// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MutableSetString = require("bs-platform/lib/js/belt_MutableSetString.js");

var inputPath = "./src/" + (Path.parse("Day07.re").name + ".input");

var dummy_input = /* array */[
  "Step C must be finished before step A can begin.",
  "Step C must be finished before step F can begin.",
  "Step A must be finished before step B can begin.",
  "Step A must be finished before step D can begin.",
  "Step B must be finished before step E can begin.",
  "Step D must be finished before step E can begin.",
  "Step F must be finished before step E can begin."
];

var input = Fs.readFileSync(inputPath, "utf8").split("\n");

function parseEdge(line) {
  var re = (/Step ([A-Z]) must be finished before step ([A-Z]) can begin./);
  var matches = Js_option.getExn(Caml_option.null_to_opt(line.match(re)));
  if (matches.length !== 3) {
    return Pervasives.failwith("invalid input");
  } else {
    var from = matches[1];
    var to_ = matches[2];
    return /* tuple */[
            from,
            to_
          ];
  }
}

var edges = $$Array.map(parseEdge, input);

function topologicalSort(edges) {
  var vertices = $$Array.fold_left((function (acc, param) {
          Belt_MutableSetString.mergeMany(acc, /* array */[
                param[0],
                param[1]
              ]);
          return acc;
        }), Belt_MutableSetString.make(/* () */0), edges);
  var _result = /* [] */0;
  var vertices$1 = vertices;
  var _edges = edges;
  while(true) {
    var edges$1 = _edges;
    var result = _result;
    if (Belt_MutableSetString.isEmpty(vertices$1)) {
      return $$Array.of_list(List.rev(result));
    } else {
      var froms = Belt_MutableSetString.toArray(Belt_MutableSetString.keep(vertices$1, (function(edges$1){
              return function (v) {
                return edges$1.every((function (param) {
                              return v !== param[1];
                            }));
              }
              }(edges$1))));
      $$Array.fast_sort(Caml_obj.caml_compare, froms);
      var nextFrom = Caml_array.caml_array_get(froms, 0);
      Belt_MutableSetString.remove(vertices$1, nextFrom);
      var nextEdges = edges$1.filter((function(nextFrom){
          return function (param) {
            return param[0] !== nextFrom;
          }
          }(nextFrom)));
      _edges = nextEdges;
      _result = /* :: */[
        nextFrom,
        result
      ];
      continue ;
    }
  };
}

var result = topologicalSort(edges).join("");

console.log("Part1 result: ", result);

var Part1 = /* module */[
  /* input */input,
  /* parseEdge */parseEdge,
  /* edges */edges,
  /* topologicalSort */topologicalSort,
  /* result */result
];

console.log("Part2 result: ", "TBD");

var Part2 = /* module */[/* input */dummy_input];

exports.inputPath = inputPath;
exports.dummy_input = dummy_input;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
