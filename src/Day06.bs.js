// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Char = require("bs-platform/lib/js/char.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Belt_MutableMapString = require("bs-platform/lib/js/belt_MutableMapString.js");
var Belt_MutableSetString = require("bs-platform/lib/js/belt_MutableSetString.js");

var inputPath = "./src/" + (Path.parse("Day06.re").name + ".input");

var dummy_input = /* array */[
  "1, 1",
  "1, 6",
  "8, 3",
  "3, 4",
  "5, 5",
  "8, 9"
];

var input = Fs.readFileSync(inputPath, "utf8").split("\n");

var points = $$Array.map((function (str) {
        var coords = $$Array.map(Caml_format.caml_int_of_string, str.split(", "));
        return /* tuple */[
                Caml_array.caml_array_get(coords, 0),
                Caml_array.caml_array_get(coords, 1)
              ];
      }), input);

var match = $$Array.fold_left((function (param, param$1) {
        var y = param$1[1];
        var x = param$1[0];
        return /* tuple */[
                Caml_primitive.caml_int_min(param[0], x),
                Caml_primitive.caml_int_max(param[1], x),
                Caml_primitive.caml_int_min(param[2], y),
                Caml_primitive.caml_int_max(param[3], y)
              ];
      }), /* tuple */[
      Pervasives.max_int,
      Pervasives.min_int,
      Pervasives.max_int,
      Pervasives.min_int
    ], points);

var maxY = match[3];

var minY = match[2];

var maxX = match[1];

var minX = match[0];

function dist(param, param$1) {
  return Pervasives.abs(param[0] - param$1[0] | 0) + Pervasives.abs(param[1] - param$1[1] | 0) | 0;
}

function findClosestPoint(points, param) {
  var y = param[1];
  var x = param[0];
  return $$Array.fold_left((function (closestPoint, param) {
                var distance = param[1];
                var id = param[0];
                if (typeof closestPoint === "number") {
                  return /* Single */Block.__(0, [
                            id,
                            distance
                          ]);
                } else if (closestPoint.tag) {
                  var distance$prime = closestPoint[0];
                  if (distance$prime <= distance) {
                    return /* Many */Block.__(1, [distance$prime]);
                  } else {
                    return /* Single */Block.__(0, [
                              id,
                              distance
                            ]);
                  }
                } else {
                  var distance$prime$1 = closestPoint[1];
                  if (distance === distance$prime$1) {
                    return /* Many */Block.__(1, [distance]);
                  } else if (distance < distance$prime$1) {
                    return /* Single */Block.__(0, [
                              id,
                              distance
                            ]);
                  } else {
                    return /* Single */Block.__(0, [
                              closestPoint[0],
                              distance$prime$1
                            ]);
                  }
                }
              }), /* None */0, points.map((function (p, id) {
                    return /* tuple */[
                            id,
                            dist(p, /* tuple */[
                                  x,
                                  y
                                ])
                          ];
                  })));
}

function pointIdToName(id) {
  return $$String.make(1, Char.chr(id + 65 | 0));
}

var board = $$Array.make_matrix((maxX - minX | 0) + 1 | 0, (maxY - minY | 0) + 1 | 0, "");

var unboundedPoints = Belt_MutableSetString.make(/* () */0);

var histogram = Belt_MutableMapString.fromArray($$Array.map((function (id) {
            return /* tuple */[
                    id,
                    0
                  ];
          }), points.map((function (param, i) {
                return pointIdToName(i);
              }))));

for(var x = minX; x <= maxX; ++x){
  for(var y = minY; y <= maxY; ++y){
    var closestPoint = findClosestPoint(points, /* tuple */[
          x,
          y
        ]);
    var exit = 0;
    if (typeof closestPoint === "number" || closestPoint.tag) {
      exit = 1;
    } else {
      var pointName = pointIdToName(closestPoint[0]);
      Caml_array.caml_array_set(Caml_array.caml_array_get(board, x - minX | 0), y - minY | 0, pointName);
      Belt_MutableMapString.update(histogram, pointName, (function (prev) {
              if (prev !== undefined) {
                return prev + 1 | 0;
              } else {
                return 1;
              }
            }));
      if (x === minX || x === maxX || y === minY || y === maxY) {
        Belt_MutableSetString.add(unboundedPoints, pointName);
      }
      
    }
    if (exit === 1) {
      Caml_array.caml_array_set(Caml_array.caml_array_get(board, x - minX | 0), y - minY | 0, ".");
    }
    
  }
}

var maxArea = $$Array.fold_left((function (p1, p2) {
        var match = p1[1] >= p2[1];
        if (match) {
          return p1;
        } else {
          return p2;
        }
      }), /* tuple */[
      "",
      Pervasives.min_int
    ], Belt_MutableMapString.toArray(histogram).filter((function (param) {
            return !Belt_MutableSetString.has(unboundedPoints, param[0]);
          })));

console.log("Part1 result: ", maxArea);

var Part1 = /* module */[
  /* input */input,
  /* points */points,
  /* minX */minX,
  /* maxX */maxX,
  /* minY */minY,
  /* maxY */maxY,
  /* dist */dist,
  /* findClosestPoint */findClosestPoint,
  /* pointIdToName */pointIdToName,
  /* board */board,
  /* unboundedPoints */unboundedPoints,
  /* histogram */histogram,
  /* maxArea */maxArea
];

var input$1 = Fs.readFileSync(inputPath, "utf8").split("\n");

var points$1 = $$Array.map((function (str) {
        var coords = $$Array.map(Caml_format.caml_int_of_string, str.split(", "));
        return /* tuple */[
                Caml_array.caml_array_get(coords, 0),
                Caml_array.caml_array_get(coords, 1)
              ];
      }), input$1);

var match$1 = $$Array.fold_left((function (param, param$1) {
        var y = param$1[1];
        var x = param$1[0];
        return /* tuple */[
                Caml_primitive.caml_int_min(param[0], x),
                Caml_primitive.caml_int_max(param[1], x),
                Caml_primitive.caml_int_min(param[2], y),
                Caml_primitive.caml_int_max(param[3], y)
              ];
      }), /* tuple */[
      Pervasives.max_int,
      Pervasives.min_int,
      Pervasives.max_int,
      Pervasives.min_int
    ], points$1);

var maxY$1 = match$1[3];

var minY$1 = match$1[2];

var maxX$1 = match$1[1];

var minX$1 = match$1[0];

function dist$1(param, param$1) {
  return Pervasives.abs(param[0] - param$1[0] | 0) + Pervasives.abs(param[1] - param$1[1] | 0) | 0;
}

var safeSpotCounter = /* record */[/* contents */0];

for(var x$1 = minX$1; x$1 <= maxX$1; ++x$1){
  (function(x$1){
  for(var y$1 = minY$1; y$1 <= maxY$1; ++y$1){
    var totalDistance = $$Array.fold_left((function(y$1){
        return function (acc, p) {
          return acc + dist$1(p, /* tuple */[
                      x$1,
                      y$1
                    ]) | 0;
        }
        }(y$1)), 0, points$1);
    if (totalDistance < 10000) {
      safeSpotCounter[0] = safeSpotCounter[0] + 1 | 0;
    }
    
  }
  }(x$1));
}

console.log("Part2 result: ", safeSpotCounter[0]);

var Part2 = /* module */[
  /* input */input$1,
  /* points */points$1,
  /* minX */minX$1,
  /* maxX */maxX$1,
  /* minY */minY$1,
  /* maxY */maxY$1,
  /* dist */dist$1,
  /* safeDistance */10000,
  /* safeSpotCounter */safeSpotCounter
];

exports.inputPath = inputPath;
exports.dummy_input = dummy_input;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
