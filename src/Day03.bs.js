// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Set = require("bs-platform/lib/js/set.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var inputPath = "./src/Day03.input";

function parseClaim(str) {
  var re = new RegExp("\\d+", "g");
  var matches = $$Array.map(Caml_format.caml_int_of_string, Js_option.getExn(Caml_option.null_to_opt(str.match(re))));
  if (matches.length !== 5) {
    return Pervasives.failwith("invalid input");
  } else {
    var id = matches[0];
    var left = matches[1];
    var top = matches[2];
    var width = matches[3];
    var height = matches[4];
    return /* record */[
            /* id */id,
            /* top */top,
            /* left */left,
            /* width */width,
            /* height */height
          ];
  }
}

var claims = $$Array.map(parseClaim, Fs.readFileSync(inputPath, "utf8").split("\n"));

var result = $$Array.fold_left((function (acc, arr) {
        return $$Array.fold_left((function (prim, prim$1) {
                      return prim + prim$1 | 0;
                    }), acc, $$Array.map((function (n) {
                          var match = n > 1;
                          if (match) {
                            return 1;
                          } else {
                            return 0;
                          }
                        }), arr));
      }), 0, $$Array.fold_left((function (fabric, claim) {
            for(var dx = 0 ,dx_finish = claim[/* width */3] - 1 | 0; dx <= dx_finish; ++dx){
              for(var dy = 0 ,dy_finish = claim[/* height */4] - 1 | 0; dy <= dy_finish; ++dy){
                Caml_array.caml_array_set(Caml_array.caml_array_get(fabric, claim[/* left */2] + dx | 0), claim[/* top */1] + dy | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(fabric, claim[/* left */2] + dx | 0), claim[/* top */1] + dy | 0) + 1 | 0);
              }
            }
            return fabric;
          }), $$Array.make_matrix(1000, 1000, 0), claims));

console.log("Part1 result: " + String(result));

var Part1 = /* module */[
  /* parseClaim */parseClaim,
  /* claims */claims,
  /* result */result
];

function parseClaim$1(str) {
  var re = new RegExp("\\d+", "g");
  var matches = $$Array.map(Caml_format.caml_int_of_string, Js_option.getExn(Caml_option.null_to_opt(str.match(re))));
  if (matches.length !== 5) {
    return Pervasives.failwith("invalid input");
  } else {
    var id = matches[0];
    var left = matches[1];
    var top = matches[2];
    var width = matches[3];
    var height = matches[4];
    return /* record */[
            /* id */id,
            /* top */top,
            /* left */left,
            /* width */width,
            /* height */height
          ];
  }
}

var claims$1 = $$Array.map(parseClaim$1, Fs.readFileSync(inputPath, "utf8").split("\n"));

var fabric = $$Array.fold_left((function (fabric, claim) {
        for(var dx = 0 ,dx_finish = claim[/* width */3] - 1 | 0; dx <= dx_finish; ++dx){
          for(var dy = 0 ,dy_finish = claim[/* height */4] - 1 | 0; dy <= dy_finish; ++dy){
            var match = Caml_array.caml_array_get(Caml_array.caml_array_get(fabric, claim[/* left */2] + dx | 0), claim[/* top */1] + dy | 0);
            var tmp;
            tmp = typeof match === "number" ? /* Single */Block.__(0, [claim[/* id */0]]) : (
                match.tag ? /* Multi */Block.__(1, [/* :: */[
                        claim[/* id */0],
                        match[0]
                      ]]) : /* Multi */Block.__(1, [/* :: */[
                        claim[/* id */0],
                        /* :: */[
                          match[0],
                          /* [] */0
                        ]
                      ]])
              );
            Caml_array.caml_array_set(Caml_array.caml_array_get(fabric, claim[/* left */2] + dx | 0), claim[/* top */1] + dy | 0, tmp);
          }
        }
        return fabric;
      }), $$Array.make_matrix(1000, 1000, /* None */0), claims$1);

var compare = Caml_obj.caml_compare;

var IntSet = $$Set.Make(/* module */[/* compare */compare]);

var badIds = $$Array.fold_left((function (badIds, arr) {
        return $$Array.fold_left((function (badIds, claims) {
                      if (typeof claims === "number" || !claims.tag) {
                        return badIds;
                      } else {
                        return Curry._2(IntSet[/* union */6], badIds, Curry._1(IntSet[/* of_list */25], claims[0]));
                      }
                    }), badIds, arr);
      }), IntSet[/* empty */0], fabric);

var result$1 = $$Array.map((function (c) {
          return c[/* id */0];
        }), claims$1).filter((function (id) {
        return !Curry._2(IntSet[/* mem */2], id, badIds);
      }));

console.log("Part2 result: " + String(Caml_array.caml_array_get(result$1, 0)));

var Part2 = /* module */[
  /* parseClaim */parseClaim$1,
  /* claims */claims$1,
  /* fabric */fabric,
  /* IntSet */IntSet,
  /* badIds */badIds,
  /* result */result$1
];

exports.inputPath = inputPath;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* claims Not a pure module */
